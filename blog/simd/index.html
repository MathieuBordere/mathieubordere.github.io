<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>LetMeTweakIt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://letmetweakit.com/style.css">
</head>

<body>
  <!-- Mobile navigation toggle -->
  <input type="checkbox" id="mobile-nav-toggle" class="mobile-nav-toggle">
  <label for="mobile-nav-toggle" class="mobile-toggle-label">
    <span></span>
  </label>

  <!-- Hidden anchor targets for navigation state -->
  <div id="blog-expanded" class="nav-target"></div>
  <div id="blog-collapsed" class="nav-target"></div>

  <!-- Tree Navigation Sidebar -->
  <nav class="sidebar">
    <a href="https://letmetweakit.com" class="site-title">LetMeTweakIt</a>
    <div class="social-links">
      <a href="https://www.linkedin.com/in/mathieu-border%C3%A9/" target="_blank" rel="noopener" class="social-icon" title="LinkedIn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
        </svg>
      </a>
      <a href="https://github.com/MathieuBordere" target="_blank" rel="noopener" class="social-icon" title="GitHub">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
      </a>
      <a href="mailto:mathieu@letmetweakit.com" class="social-icon email-icon" title="mathieu@letmetweakit.com">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
        </svg>
      </a>
    </div>
    <div class="build-time">Built: 2025-12-11 08:55 UTC</div>
    <ul class="nav-tree">
      <li>
        <a href="https://letmetweakit.com/blog/" class="nav-item">
          <span class="nav-icon no-children">•</span>
          Blog
        </a>
      </li>
      <li>
        <a href="https://letmetweakit.com/about/" class="nav-item">
          <span class="nav-icon no-children">•</span>
          About
        </a>
      </li>
    </ul>
  </nav>

  <!-- Main Content -->
  <main class="main-content">
    <section class="section">
      <div class="container">
        
<h1 class="title">
  A gentle introduction to SIMD.
</h1>
<p class="subtitle"><strong>2025-09-18</strong></p>
<p>A few weeks ago I was reading up on the <a href="https://github.com/gunnarmorling/1brc">one billion row challenge</a> and was wondering what the fastest way
would be to read a file from disk. For comparison I decided it would be
interesting to find out how <code>wc</code> does it on my Fedora 42 workstation. Turns out
<code>wc</code> just uses <code>read</code> but with a buffersize of 256KiB, a value that seems to be <a href="https://github.com/coreutils/coreutils/blob/dc30eab3146163be18b70d8d5fed63706b6a4110/src/ioblksize.h#L25">optimized for an
average
system</a>.</p>
<p>My attention immediately diverted to the actual implementation that uses AVX2
when available, I've never really taken a closer look at SIMD instructions
before and decided it was the right moment as the code didn't look daunting.</p>
<pre data-linenos data-lang="c" style="background-color:#fefbec;color:#6e6b5e;" class="language-c "><code class="language-c" data-lang="c"><table><tbody><tr><td>1</td><td><span style="color:#b854d4;">extern struct </span><span>wc_lines
</span></td></tr><tr><td>2</td><td><span>wc_lines_avx2 (int fd)
</span></td></tr><tr><td>3</td><td><span>{
</span></td></tr><tr><td>4</td><td><span>  intmax_t lines = </span><span style="color:#b65611;">0</span><span>;
</span></td></tr><tr><td>5</td><td><span>  intmax_t bytes = </span><span style="color:#b65611;">0</span><span>;
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td><mark style="background-color:#99958055;">7</mark></td><td><mark style="background-color:#99958055;"><span>  __m256i endlines = </span><span style="color:#d73737;">_mm256_set1_epi8 </span><span>(&#39;</span><span style="color:#1fad83;">\n</span><span>&#39;);
</span></mark></td></tr><tr><td>8</td><td><span>
</span></td></tr><tr><td>9</td><td><span>  </span><span style="color:#b854d4;">while </span><span>(</span><span style="color:#b65611;">true</span><span>)
</span></td></tr><tr><td>10</td><td><span>    {
</span></td></tr><tr><td>11</td><td><span>       __m256i avx_buf[IO_BUFSIZE / sizeof (__m256i)];
</span></td></tr><tr><td>12</td><td><span>      ssize_t bytes_read = </span><span style="color:#d73737;">read </span><span>(fd, avx_buf, sizeof avx_buf);
</span></td></tr><tr><td>13</td><td><span>      </span><span style="color:#b854d4;">if </span><span>(bytes_read &lt;= </span><span style="color:#b65611;">0</span><span>)
</span></td></tr><tr><td>14</td><td><span>        </span><span style="color:#b854d4;">return </span><span>(</span><span style="color:#b854d4;">struct</span><span> wc_lines) { bytes_read == </span><span style="color:#b65611;">0 </span><span>? </span><span style="color:#b65611;">0 </span><span>: errno, lines, bytes };
</span></td></tr><tr><td>15</td><td><span>
</span></td></tr><tr><td>16</td><td><span>      bytes += bytes_read;
</span></td></tr><tr><td>17</td><td><span>      __m256i *datap = avx_buf;
</span></td></tr><tr><td>18</td><td><span>
</span></td></tr><tr><td>19</td><td><span>      </span><span style="color:#b854d4;">while </span><span>(bytes_read &gt;= </span><span style="color:#b65611;">32</span><span>)
</span></td></tr><tr><td>20</td><td><span>        {
</span></td></tr><tr><td><mark style="background-color:#99958055;">21</mark></td><td><mark style="background-color:#99958055;"><span>           __m256i to_match = </span><span style="color:#d73737;">_mm256_load_si256 </span><span>(datap);
</span></mark></td></tr><tr><td><mark style="background-color:#99958055;">22</mark></td><td><mark style="background-color:#99958055;"><span>           __m256i matches = </span><span style="color:#d73737;">_mm256_cmpeq_epi8 </span><span>(to_match, endlines);
</span></mark></td></tr><tr><td><mark style="background-color:#99958055;">23</mark></td><td><mark style="background-color:#99958055;"><span>           </span><span style="color:#b854d4;">int</span><span> mask = </span><span style="color:#d73737;">_mm256_movemask_epi8 </span><span>(matches);
</span></mark></td></tr><tr><td>24</td><td><span>           lines += </span><span style="color:#d73737;">__builtin_popcount </span><span>(mask);
</span></td></tr><tr><td>25</td><td><span>           datap += </span><span style="color:#b65611;">1</span><span>;
</span></td></tr><tr><td>26</td><td><span>           bytes_read -= </span><span style="color:#b65611;">32</span><span>;
</span></td></tr><tr><td>27</td><td><span>        }
</span></td></tr><tr><td>28</td><td><span>
</span></td></tr><tr><td>29</td><td><span>      </span><span style="color:#999580;">/* Finish up any left over bytes */
</span></td></tr><tr><td>30</td><td><span>      </span><span style="color:#b854d4;">char </span><span>*end = (</span><span style="color:#b854d4;">char </span><span>*) datap + bytes_read;
</span></td></tr><tr><td>31</td><td><span>      </span><span style="color:#b854d4;">for </span><span>(</span><span style="color:#b854d4;">char </span><span>*p = (</span><span style="color:#b854d4;">char </span><span>*) datap; p &lt; end; p++)
</span></td></tr><tr><td>32</td><td><span>        lines += *p == &#39;</span><span style="color:#1fad83;">\n</span><span>&#39;;
</span></td></tr><tr><td>33</td><td><span>    }
</span></td></tr><tr><td>34</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>The algorithm is pretty simple. It first prepares a 256 bit buffer with 32 <code>\n</code> values at L7,
then reads a chunk of data, and as long as there is data to read, it loads 256
bits of the data at L21 and compares the data with the buffer of newlines using
<code>_mm256_cmpeq_epi8</code>. This sets the corresponding bits of the matches buffer to all
1's in case a data byte is a newline or all 0's in case it's not.</p>
<p>To count the number of lines, <code>_mm256_movemask_epi8</code> creates a mask from the most significant bit of each
byte of the source vector and stores the result in the returned value, in short it transforms <code>11111111</code> (a newline match)
into <code>10000000</code>, and leaves <code>00000000</code> alone. Now what remains is counting the
number of set bits in the mask with <code>__builtin_popcount</code>.</p>
<p>That's it! The remainder is some accounting when there's leftover data that is
too small to fit an AVX2 instruction. Now, that was a gentle introduction, wasn't it?</p>


      </div>
    </section>
  </main>
</body>

</html>
